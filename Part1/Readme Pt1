###################################################################
#	          ΑΝΑΠΤΥΞΗ ΛΟΓΙΣΜΙΚΟΥ - ΕΠΙΠΕΔΟ 1					  #
#																  #
#	Α.Μ.: 111520110004  - ΛΗΔΑ-ΚΥΡΙΑΚΗ ΖΑΧΑΡΟΠΟΥΛΟΥ               #
#	A.M.: 111520110040  - ΓΙΩΡΓΟΣ ΛΑΜΠΡΑΚΟΠΟΥΛΟΣ                  #
#	A.M.: 1115201100151 - ΠΑΝΑΓΙΩΤΗΣ ΠΑΠΑΓΕΩΡΓΙΟΥ                 #
#                                                                 #
###################################################################

Βαθμός Ολοκλήρωσης της Εργασίας (14/11/2014):

=============================ΚΑΤΑΣΤΑΣΗ ΕΡΓΑΣΙΑΣ===================================

Έχουν υλοποιηθεί όλες οι λειτουργίες που απαιτείται να πραγματοποιεί το πρόγραμμα.
Ωστόσο δεν λειτουργούν όλα σωστά, συγκεκριμένα αυτή τη στιγμή αντιμετωπίζουμε
πρόβλημα μνήμης με τους αλγορίθμους που διατρέχουν το γράφο στη reachNode1, επίσης
προσπαθούμε να επιλύσουμε ένα πρόβλημα μνήμης που δημιουργείται κατά τη δημιουργία
κάδου υπερχείλισης. Τέλος δεν έχει προσαρμοστεί η υλοποίηση ακόμα στα αρχεία που μας
δώσατε.

===================================================================================

========================ΟΔΗΓΙΕΣ ΜΕΤΑΓΛΩΤΤΙΣΗΣ=======================================
Για μεταγλώττιση: 

	gcc -o level1 main.c hash.c bucket.c datatypes.c uberlist.c reader.c graph.c gtools.c -lm

====================================================================================

=======================ΜΈΡΗ ΕΡΓΑΣΙΑΣ================================================

----------------------ΜΗΧΑΝΙΣΜΟΣ ΚΑΤΑΚΕΡΜΑΤΙΣΜΟΥ: (hash.c, graph.c)----------------

ΔΗΜΙΟΥΡΓΟΣ: ΛΗΔΑ-ΚΥΡΙΑΚΗ ΖΑΧΑΡΟΠΟΥΛΟΥ

To ευρετήριο μας είναι ένας δυναμικά δεσμευμένος πίνακας που σε κάθε κελί
έχει δείκτη σε Bucket. Γίνεται realloc όποτε χρειάζεται.

 Στην insertNode,κάθε κόμβος περνάει πάντα πρώτα από τη αρχική hash function του 
split round (i) όπου βρισκόμαστε,με h(i)= key%2^i*m,και m πάντα το αρχικό 
μέγεθος του hashtable.Ο δείκτης p μας δείχνει τη θέση στον πίνακα που θα γίνει 
το επόμενο split.Aν η θέση στον πίνακα(pos) που μας επιστρέψει η hash
αντιστοιχεί σε θέσεις που έχουν ήδη γίνει splitted(δηλαδή pos < p),ο κόμβος 
ξαναστέλνει το id του για hash,αυτή τη φορά στην συνάρτηση h(i+1).Κάθε bucket 
δημιουργείται μόνο εφόσον κάποιος κόμβος εισέρχεται σε αυτόν και όχι εκ
των προτέρων.

 Η συνθήκη για να γίνει split είναι αν με την εισαγωγή ενός κόμβου 
δημιουργείται αλυσίδα υπερχείλισης.Αν έχουμε συνθήκη για split και εφόσον ο 
πίνακας δεν έχει φτάσει σε διπλάσιο μέγεθος από αυτό που είχε στην αρχή του 
επιπέδου,δημιουργείται μια καινούργια θέση στον πίνακα,και οι εγγραφές όλης της
αλυσίδας του κάδου που έγινε το split ανακατανέμονται μεταξύ παλιού και 
καινούργιου χρησιμοποιώντας ως hash function την h(i+1).Στην πραγματίκότητα το 
μέγεθος του πίνακα στη μνήμη διπλασιάζεται μέσω realloc,ώστε να μην αυξάνεται 
συνεχώς κατά 1.Πάλι,ο καινούργιος κάδος θα δεσμευτεί μόνο αν κάποια εγγραφή πάει
τελικά σε αυτόν.Αν έχουμε συνθήκη για split και ο πίνακας έχει φτάσει στο 
διπλάσιο από αυτό που είχε στην αρχή του επιπέδου,σημαίνει ότι όλοι οι κάδοι 
έχουν γίνει splitted και άρα περνάμε στο επόμενο split round (i++) και το p 
αρχικοποιείται ξανά με 0.

-------------------ΔΙΑΧΕΙΡΙΣΗ ΚΟΥΒΑΔΩΝ(bucket): (bucket.c)----------------------

ΔΗΜΙΟΥΡΓΟΣ: ΓΙΩΡΓΟΣ ΛΑΜΠΡΑΚΟΠΟΥΛΟΣ

 Το bucket είναι μια δομή που περιέχει μια λίστα από κόμβους του Γράφου (GraphNode),
το όριο κόμβων που μπορεί να φυλάξει (c) καθώς και ένα δείκτη σε κάδο υπερχείλισης.

Επιλέξαμε να έχουμε μια συνδεδεμένη λίστα από κόμβους γιατί θεωρήσαμε ότι είναι πιο
ευέλικτη κατά την εισαγωγή/εξαγωγή εγγραφών από αυτή, γνωρίζουμε ωστόσο ότι θυσιάζουμε
τη δυνατότητα να αναζητήσουμε με δυαδική αναζήτηση στοιχεία το ίδιο γρήγορα που θα
τα αναζητούσαμε αν είχαμε πίνακα.

Χρησιμοποιούμε ωστόσο διπλά συνδεδεμένη λίστα που δείχνει στο πρώτο, στο τελευταίο
καθώς και στο μεσαίο κόμβο της βοηθώντας έτσι κατά πολύ εισαγωγή και εξαγωγή στοιχείων.

Η διαχείριση μιας λίστας από GraphNodes γίνεται μέσω των συναρτήσεων με πρόθεμα
GNL (GraphNode List).

- Δεν έχουμε υλοποιήσει ακόμα τη δυαδική αναζήτηση. Η αναζήτησ προς το παρόν γίνεται
με απλή σειριακή αναζήτηση.

----------------ΣΥΝΑΡΤΗΣΕΙΣ ΕΞΕΡΕΥΝΗΣΗ ΤΟΥ ΓΡΑΦΟΥ ΚΑΙ Generic List-----------------

ΔΗΜΙΟΥΡΓΟΣ: ΠΑΝΑΓΙΩΤΗΣ ΠΑΠΑΓΕΩΡΓΙΟΥ

---Generic List---: (uberlist.c)

 Αποφύγαμε τη δημιουργία πολλαπλών υλοποιήσεων λίστας δημιουγώντας μία λίστα
που σε κάθε κόμβο φέρνει ένα void* δείκτη. Με αυτόν τον τρόπο μπορούμε να έχουμε
οτιδήποτε δεδομένα θέλουμε.

Για να μπορέσει ωστόσο η λίστα αυτή σωστά, πρέπει κατά την δημιουργία της να της δωθούν
δείκτες σε συναρτήσεις για να γίνεται το σωστό allocation,destruction,assignment,print
και comparison των κόμβων της. Έτσι κάθε φορά που θέλουμε να δημιουργούμε λίστες κάποιου
καινούργιου τύπου γράφουμε αντίστοιχες τέτοιες συναρτήσεις.

---ΕΞΕΡΕΎΝΗΣΗ ΓΡΆΦΟΥ---

 Το ResultSet μας είναι μια δομή που περιέχει μέσα 3 άλλες δομές. Μια λίστα set, μία λίστα
queue και μια λίστα results. Οι 2 πρώτες είναι απαραίτητες για να προχωράει όποτε γίνεται 
next ο BFS μας και να παίρνουμε νέο αποτέλεσμα για το ResultSet. Η λίστα results απλά κρατάει
όλα τα αποτελέσματα.

Για την reachNode1 έχει υλοποιηθεί διπλός BFS ο οποίος χρησιμοποιεί 2 queues και 2 sets ώστε
να προχωράει ένας BFS από την αρχή και ένας από το τέλος. 

ΝΑ ΣΗΜΕΙΣΩΘΕΙ εδώ ότι αυτοί οι 2 BFS αλγόριθμοι αλλάζουν λίγο σε λογική από τον κλασσικό BFS.
Αντί να ανοίγει ένας ένας κόμβος του frontier και να τσεκάρεται αν είναι το GOAL, εδώ γίνεται
διαφορετικά: Ο κάθε BFS πρώτα ανοίγει κατά πλάτος όλους τους κόμβους που είναι στο ίδιο επίπεδο
και μετά κοιτάνε οι 2 BFS αν υπάρχει τομή και αν είναι η ελάχιστη.

ΔΕΝ έχει υλοποιηθεί έλεγχος για το αν ο γράφος είναι unidirectional ή όχι.

====================ΕΥΧΑΡΙΣΤΟΥΜΕ ΓΙΑ ΤΟ ΧΡΟΝΟ ΣΑΣ!========================================


